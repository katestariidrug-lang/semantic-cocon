Вот README проекта. Используй его как описание архитектуры и принципов работы.

# semantic-cocon

## Назначение проекта

> Workflow для работы с LLM, где сначала принимаются решения, затем выполняется генерация, а результат можно проверить и воспроизвести.
> Детерминированный двухпроходный workflow работы с LLM: архитектура отдельно, исполнение отдельно, результат — проверяемый.

Ключевая идея проекта:
> LLM не управляет состоянием, не проверяет саму себя и не принимает финальные решения.
> Она используется только как исполнитель строго заданных шагов.

Проект решает типичную проблему LLM‑подходов:
- архитектура «плывёт» от запуска к запуску,
- результат невозможно воспроизвести,
- нельзя доказать, что выход соответствует принятой структуре.

В `semantic-cocon` это запрещено на уровне пайплайна.

---

## Быстрый старт (Quick Start)

Ниже — минимальный сценарий, который позволяет запустить проект и пройти весь цикл от архитектуры до проверенного результата.

```bash
# PASS_1 — принять архитектурные решения
python -m scripts.orchestrator decide

# проверить корректность snapshot
python scripts/gate_snapshot.py <snapshot_id>

# подтвердить snapshot (human step)
# создать файл state/approvals/<hash>.approved

# PASS_2 — выполнить генерацию по зафиксированной архитектуре
python -m scripts.orchestrator execute --snapshot state/snapshots/<snapshot_id>.snapshot.json

# проверить результат
python scripts/check_deliverables.py <snapshot_id>
```

Если любой шаг завершается с ошибкой — процесс считается неуспешным.

---

## Как понимать PASS_1 и PASS_2 (если коротко)

Проект намеренно разделяет работу с LLM на два разных шага, потому что это **разные по смыслу действия**.

### PASS_1 — DECIDE (принять решения)

На этом шаге мы решаем **ЧТО именно будем делать**, но ничего ещё не генерируем.

Проще всего думать о PASS_1 как о **плане или чертеже**:

- какие страницы (узлы) будут существовать;
- какая страница главная;
- какие страницы второстепенные;
- какие страницы вспомогательные;
- какие страницы должны ссылаться друг на друга.

На PASS_1 LLM **запрещено писать контент**. Она не генерирует тексты, вопросы или ключевые слова. Она только описывает структуру будущего результата.

Результат PASS_1 — это зафиксированная архитектура (snapshot), которая дальше считается контрактом.

### PASS_2 — EXECUTE (сгенерировать deliverables по зафиксированной архитектуре)

⚠️ Это **единственный шаг всего workflow, на котором LLM генерирует выходные артефакты** (структурированные данные), а не принимает решения.

На этом шаге мы делаем ровно то, что уже решили на PASS_1.

LLM получает готовый "чертёж" и:

Важно: проект **не предназначен для написания текстов страниц**. PASS_2 генерирует только структурированные deliverables (например, ключевые слова, вопросы, анкоры, сводные таблицы) в формате JSON.

- заполняет каждую страницу контентом;
- генерирует вопросы, ключевые слова, анкоры;
- создаёт итоговые артефакты.

При этом LLM **не может**:

- добавлять новые страницы;
- удалять существующие;
- менять структуру;
- изменять связи между страницами.

PASS_2 — это строгое исполнение зафиксированной архитектуры без права передумывать.

### Почему это разделено

Если не разделять эти шаги, LLM будет одновременно:
- менять структуру,
- писать контент,
- «улучшать» задним числом.

В таком режиме результат невозможно проверить или воспроизвести.

Разделение PASS_1 / PASS_2:

- лишает LLM права самовольно менять структуру;
- даёт контроль над процессом;
- делает результат проверяемым.

---

## Инварианты проекта

Следующие правила считаются **неизменяемыми** и не подлежат пересмотру без полного рефакторинга архитектуры:

- PASS_1 и PASS_2 никогда не объединяются.
- PASS_2 не может менять архитектуру snapshot.
- Архитектура после создания snapshot считается immutable.
- Любой результат без post-check deliverables считается недействительным.
- LLM не является источником истины о состоянии проекта.
- Все проверки выполняются вне LLM.

Любое изменение, нарушающее эти правила, считается архитектурной ошибкой.

---

## Общая архитектура workflow

Workflow состоит из **двух жёстко разделённых проходов**:

- **PASS_1 — DECIDE**: принятие архитектурных решений
- **PASS_2 — EXECUTE**: исполнение строго по зафиксированной архитектуре

Между ними находятся обязательные контрольные точки:

```
DECIDE
  ↓
SNAPSHOT + HASH
  ↓
APPROVE (human)
  ↓
EXECUTE
  ↓
POST-CHECK (deliverables)
```

Каждый шаг либо проходит валидацию, либо останавливает процесс.

---

## PASS_1: DECIDE

### Назначение

PASS_1 **не генерирует контент**.
Он принимает **архитектурные решения**, которые дальше считаются контрактом.

### Что именно определяется

- `node_registry` — список узлов
- типы узлов: `HUB / SPOKE / SUPPORT`
- `hub_chain` — цепочка главного хаба
- `linking_matrix_skeleton` — скелет внутренней линковки
- ownership узлов (owner records)

### Источники данных

- `input/task.json` — входная постановка задачи
- `prompts/pass_1_decide.md` — системный промпт PASS_1
- LLM вызывается через `scripts/llm_cli_bridge.py`

### Результат PASS_1

PASS_1 формирует snapshot архитектуры:

- `*.snapshot.json` — зафиксированное решение
- `*.canonical.json` — каноническое представление
- `*.sha256` — hash immutable‑части

Файлы сохраняются в:

```
state/snapshots/
```

После этого архитектура считается **замороженной**.

---

## Snapshot и принцип immutability

Snapshot — это **архитектурный контракт**, а не просто JSON.

В блоке `immutable_architecture` находятся:

- `node_registry`
- `hub_chain`
- `linking_matrix_skeleton`
- `owner_map` (фактически список owner‑records)

Любая попытка:
- изменить количество узлов,
- поменять тип узла,
- изменить линковку

должна приводить к отказу исполнения PASS_2.

---

## APPROVE (человеческий шаг)

Snapshot **не может быть исполнен автоматически**.

Для разрешения EXECUTE требуется файл подтверждения:

```
state/approvals/<hash>.approved
```

Где `<hash>` — значение из `*.sha256` snapshot‑файла.

Это:
- явная точка ответственности человека,
- защита от самовольного исполнения,
- отделение «решения» от «исполнения».

---

## PASS_2: EXECUTE

### Назначение

PASS_2 **не принимает архитектурных решений**.
Он строго исполняет то, что зафиксировано в snapshot.

### Проверки перед запуском

Перед началом EXECUTE:

- проверяется hash snapshot
- проверяется наличие approval‑файла
- проверяется неизменяемость immutable‑части

Без этих условий PASS_2 не запускается.

### Источники данных

- `state/snapshots/*.snapshot.json` — архитектура
- `prompts/pass_2_execute.md` — системный промпт PASS_2
- LLM через `scripts/llm_cli_bridge.py`

### Результат PASS_2

PASS_2 создаёт набор deliverables:

```
outputs/pass_2/<snapshot_id>/
├── keywords.json
├── patient_questions.json
├── semantic_enrichment.json
├── anchors.json
├── final_artifacts.json
├── execution_result.json
└── execution_result.raw.txt
```

---

## Где допустимы изменения

Тип изменения напрямую определяет, **на каком шаге оно может быть внесено**:

| Тип изменения | Где допустимо |
|--------------|---------------|
| Изменение структуры узлов | PASS_1 |
| Изменение типов узлов (HUB / SPOKE / SUPPORT) | PASS_1 |
| Изменение линковки | PASS_1 |
| Изменение контента узлов | PASS_2 |
| Изменение анкоров | PASS_2 |
| Изменение проверок | scripts / orchestrator |
| Изменение логики approve | orchestrator |

Если изменение не попадает ни в одну категорию — оно считается некорректно сформулированным.

---

## Типы deliverables

### Per‑node артефакты

Должны покрывать **все `node_id` из snapshot**:

- `keywords.json`
- `patient_questions.json`
- `semantic_enrichment.json`

### Link‑level артефакты

- `anchors.json`
- используют `from_node_id / to_node_id`
- проверяются на соответствие `linking_matrix_skeleton`

### Aggregate‑артефакты

- `final_artifacts.json`
- агрегированный итог
- не обязаны иметь `node_id`

---

## Post‑check deliverables (обязательный гейт)

После успешного EXECUTE автоматически запускается:

```
scripts/check_deliverables.py <snapshot_id>
```

Проверяется:

- покрытие всех `node_id` в per‑node артефактах
- валидность anchors
- наличие и непустота aggregate‑результатов

Если проверка не проходит:

- EXECUTE считается **проваленным**
- пайплайн останавливается

LLM не может «протащить» некорректный результат.

---

## Структура репозитория

Ключевые директории проекта:

```
input/        — входные данные задачи
prompts/      — системные промпты PASS_1 и PASS_2
scripts/      — оркестратор и проверки
state/        — snapshots, approvals, runtime-состояние
outputs/      — результаты PASS_2 (deliverables)
```

---

## Оркестратор

### Файл

```
scripts/orchestrator.py
```

### Режимы работы

- `decide`
- `approve`
- `execute`

Запуск **только как модуль**:

```bash
python -m scripts.orchestrator <command>
```

Оркестратор:

- не хранит состояние
- не доверяет LLM
- управляет порядком шагов и проверками

---

## Канонический ручной workflow

Для одного snapshot:

```bash
python scripts/gate_snapshot.py <snapshot_id>
# создать approvals/<hash>.approved
python -m scripts.orchestrator execute --snapshot state/snapshots/<snapshot_id>.snapshot.json
python scripts/check_deliverables.py <snapshot_id>
```

Если любой шаг падает — процесс считается неуспешным.

---

## Ответственности компонентов

| Компонент | Ответственность |
|---------|----------------|
| PASS_1 | Архитектура |
| Snapshot | Контракт |
| Approve | Человеческое решение |
| PASS_2 | Исполнение |
| Post‑check | Контроль качества |
| Orchestrator | Порядок и запреты |

---

## Что проект **не** делает

Важно понимать ограничения проекта:

- проект **не** предназначен для «просто генерации текста»
- LLM **не** принимает финальные решения
- результат **не** считается корректным без проверок
- пайплайн **не** продолжает работу при нарушении архитектуры

Если нужен быстрый, неконтролируемый вывод — этот проект избыточен.

---

## Итог

`semantic-cocon` превращает работу с LLM из генерации «на доверии» в **проверяемый инженерный процесс**:

- архитектура отделена от исполнения
- решения фиксируются
- каждое действие верифицируется
- результат либо доказуемо корректен, либо отвергнут

Это основа для масштабируемых и воспроизводимых LLM‑систем.

