# TODO: дальнейшие задачи по проекту semantic-cocon

Этот список фиксирует следующие шаги развития проекта после базовой стабилизации архитектуры и README.

Проект находится в фазе:  
**«из рабочего прототипа → в управляемую систему»**.

---

## 1. Довести README до статуса архитектурного контракта

### 1.1. Зафиксировать инварианты проекта
Добавить и проверить наличие раздела **«Инварианты проекта»** с жёсткими формулировками:

- PASS_1 и PASS_2 никогда не объединяются
- PASS_2 не может менять архитектуру snapshot
- snapshot после approve считается immutable
- результат без post-check считается недействительным
- LLM не является источником истины о состоянии проекта

**Зачем:**  
Чтобы ни человек, ни LLM не предлагали «аккуратные улучшения», которые ломают систему.

---

### 1.2. Явно зафиксировать: проект не пишет тексты
Проверить README на отсутствие двусмысленных формулировок.

Должно быть явно сказано:
- проект **не предназначен для написания текстов страниц**
- PASS_2 генерирует **только структурированные JSON-артефакты**

**Зачем:**  
Иначе любой новый участник (и ChatGPT) будет ожидать текстовую генерацию.

---

### 1.3. Добавить раздел «Типы изменений и где они допустимы»
Таблица вида:

- изменение структуры узлов → PASS_1
- изменение линковки → PASS_1
- изменение семантических артефактов → PASS_2
- изменение проверок → scripts / orchestrator
- изменение approve-логики → orchestrator

**Зачем:**  
Чтобы сразу было понятно, *где* решается каждая задача.

---

## 2. Зафиксировать проверки как часть архитектуры

### 2.1. Описать обязательные проверки в README
Добавить раздел:

- проверка структуры snapshot
- проверка immutability
- проверка approve
- проверка deliverables (покрытие всех node_id)

**Зачем:**  
Без этого проект выглядит как набор скриптов, а не система с контрактами.

---

### 2.2. Привести проверки к единому соглашению
Определить и зафиксировать:
- имена файлов проверок
- единый формат вывода
- что считается FAIL / BLOCKER

**Зачем:**  
Чтобы проверки не разъехались при дальнейшем развитии.

---

## 3. Описать lifecycle состояния проекта

### 3.1. Явно описать lifecycle snapshot
В README или отдельном блоке:

DECIDE  
→ snapshot.json  
→ sha256  
→ approve  
→ execute  
→ outputs  

С указанием:
- где точка невозврата
- что запрещено делать после approve

**Зачем:**  
Чтобы состояние проекта не «плыло» и не интерпретировалось по-разному.

---

### 3.2. Зафиксировать stateless-природу LLM
Прямо указать:
- LLM не хранит состояние
- всё состояние живёт только в `state/`
- LLM не может быть источником правды о прошлом шаге

**Зачем:**  
Чтобы модель не начинала «помнить» то, чего помнить нельзя.

---

## 4. Подготовить проект к работе с ChatGPT как инструментом

### 4.1. Сделать короткий System Context (10–15 строк)
На основе README подготовить краткий контекст, который можно вставлять в каждый новый чат.

**Зачем:**  
Чтобы не объяснять архитектуру заново в каждом диалоге.

---

### 4.2. Добавить раздел «Как ставить задачи ChatGPT»
Примеры корректных формулировок:
- «Проверь, не нарушает ли это изменение инварианты»
- «Определи, на каком шаге должен быть внесён change»
- «Предложи проверку, не меняя архитектуру»

Примеры некорректных:
- «Как улучшить проект»
- «Давай упростим»
- «Можно ли сделать по-другому»

**Зачем:**  
Чтобы ChatGPT работал в рамках системы, а не «помогал от себя».

---

## 5. Минимальная техническая гигиена

### 5.1. Убедиться, что в репозитории нет диагностического мусора
- временные дампы
- файлы для навигации
- одноразовые проверки

### 5.2. Проверить соответствие README и структуры репозитория
- папки существуют
- названия совпадают
- README — единственная точка входа

**Зачем:**  
Чтобы проект выглядел как целостная система, а не рабочая папка.

---

## Итоговое состояние, к которому нужно прийти

Проект должен:
- быть понятен без устных пояснений
- иметь зафиксированные правила игры
- быть пригоден для работы с LLM как инструментом
- быть расширяем без слома архитектуры
