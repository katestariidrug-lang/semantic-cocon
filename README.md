Зачем каждый каталог

**prompts/**
- pass_1_decide.md — промпт PASS_1, который ТОЛЬКО принимает архитектурные решения.
- pass_2_execute_core.md — PASS_2A (CORE): per-node артефакты (semantic_enrichment, keywords, patient_questions).
- pass_2_execute_anchors.md — PASS_2B (ANCHORS): link-level артефакты (anchors).

**input/**
- task.json — вход задачи: domain, goal, region, seed-данные.
Этот файл один и тот же для PASS_1 и PASS_2.

**state/**
- snapshots/ — сохранённые ARCH_DECISION_JSON + hash.
- approvals/ — файлы человеческого подтверждения (флаг, подпись, whatever).
LLM сюда не пишет. Только Python.

**outputs**
- pass_2/ — финальные артефакты PASS_2: структурированные JSON-deliverables и сводные результаты (при необходимости — вспомогательные MD-отчёты, но не тексты страниц).
Всё, что можно отдать дальше в работу.

**scripts/**
- state_utils.py — canonicalize, hash, save, load, verify.
- orchestrator.py — decide / approve / execute.
Без классов ради классов. Это не фреймворк, это инструмент.


Вот README проекта. Используй его как описание архитектуры и принципов работы.

# semantic-cocon

## Назначение проекта

> Workflow для работы с LLM, где сначала принимаются архитектурные решения,
> затем выполняется строго ограниченная генерация структурированных артефактов,
> а результат можно проверить и воспроизвести.

⚠️ ВАЖНО:
Проект **не предназначен для написания текстов страниц, статей, описаний или любого иного нарративного контента**.

LLM в рамках `semantic-cocon` **никогда не генерирует тексты для публикации**.
Любая текстовая генерация считается **архитектурным нарушением** и выходит за рамки проекта.

Ключевая идея проекта:
> LLM не управляет состоянием, не проверяет саму себя и не принимает финальные решения.
> Она используется только как исполнитель строго заданных шагов.

Проект решает типичную проблему LLM‑подходов:
- архитектура «плывёт» от запуска к запуску,
- результат невозможно воспроизвести,
- нельзя доказать, что выход соответствует принятой структуре.

В `semantic-cocon` это запрещено на уровне пайплайна.

---

## Быстрый старт (Quick Start)

Ниже — минимальный сценарий, который позволяет запустить проект и пройти весь цикл от архитектуры до проверенного результата.

```bash
# PASS_1 — принять архитектурные решения
python -m scripts.orchestrator decide

# (внутренняя техническая проверка snapshot выполняется orchestrator)
# пользователь НЕ запускает gate_snapshot вручную

# APPROVE — человеческий шаг (механизирован, но не автоматизирован)
# gate_snapshot — внутренняя проверка, не заменяет approve

# APPROVE — человеческий шаг (механизирован, но не автоматизирован)
python -m scripts.orchestrator approve --snapshot <snapshot_id>

# PASS_2A — CORE (per-node артефакты)
python -m scripts.orchestrator execute \
  --stage core \
  --snapshot state/snapshots/<snapshot_id>.snapshot.json

# PASS_2B — ANCHORS (link-level артефакты)
python -m scripts.orchestrator execute \
  --stage anchors \
  --snapshot state/snapshots/<snapshot_id>.snapshot.json

# POST-CHECK — выполняется ТОЛЬКО после merge core + anchors
python scripts/check_deliverables.py <snapshot_id>

```

Если любой шаг завершается с ошибкой — процесс считается неуспешным.

---

## Как понимать PASS_1 и PASS_2 (если коротко)

Проект намеренно разделяет работу с LLM на два разных шага, потому что это **разные по смыслу действия**.

### PASS_1 — DECIDE (принять решения)

На этом шаге мы решаем **ЧТО именно будем делать**, но ничего ещё не генерируем.

Проще всего думать о PASS_1 как о **плане или чертеже**:

- какие страницы (узлы) будут существовать;
- какая страница главная;
- какие страницы второстепенные;
- какие страницы вспомогательные;
- какие страницы должны ссылаться друг на друга.

На PASS_1 LLM **запрещено писать контент**. Она не генерирует тексты, вопросы или ключевые слова. Она только описывает структуру будущего результата.

Результат PASS_1 — это зафиксированная архитектура (snapshot). Контрактом (immutable) она становится после approve; до approve допускается только выпуск нового snapshot, а не правки старого.

### PASS_2 — EXECUTE (stage-based execution)

PASS_2 разделён на **два независимых stage**, каждый из которых исполняется отдельным вызовом LLM и имеет собственный контракт:

- **PASS_2A / CORE** — per-node артефакты
- **PASS_2B / ANCHORS** — link-level артефакты

Stage-split является архитектурным решением и не может быть отключён без изменения контракта проекта.

### Stage-level invariants (CORE ↔ ANCHORS)

Эти правила запрещают “подмешивание” архитектуры и обязанностей между стадиями.

**Invariant #1 — общий immutable snapshot**
CORE и ANCHORS обязаны исполняться по одному и тому же approved snapshot (одинаковый immutable_snapshot sha256 / snapshot identity в контексте запуска). Если snapshot различается — merge запрещён.

**Invariant #2 — архитектура immutable**
Между стадиями запрещено менять любые архитектурные поля snapshot, включая (не ограничиваясь):
- состав и типы узлов (node_registry, HUB/SPOKE/SUPPORT, уровни, hub_chain),
- связи (linking_matrix / edges),
- ownership/owner_status,
- canonical_home, recommended_variant_id и любые id/ключи, которые идентифицируют архитектуру.

**Invariant #3 — разделение ответственности**
- PASS_2A / CORE: генерирует только per-node артефакты `semantic_enrichment.json`, `keywords.json`, `patient_questions.json`.
- PASS_2B / ANCHORS: генерирует только link-level артефакт `anchors.json` (ровно 1 anchor на пару связей).
Любая попытка создать/изменить “чужие” артефакты считается нарушением контракта.

**Invariant #4 — no self-control**
LLM не выполняет merge, не запускает post-check и не решает “можно ли продолжать”.
Post-check разрешён только после внешнего MERGE (external, deterministic).

⚠️ Это **единственный шаг всего workflow, на котором LLM генерирует выходные артефакты** (структурированные данные), а не принимает решения.

На этом шаге мы делаем ровно то, что уже решили на PASS_1.

LLM получает готовый "чертёж" (ARCH_DECISION_JSON),
который является ЕДИНСТВЕННЫМ источником истины для PASS_2, и:

⚠️ ЖЁСТКОЕ ОГРАНИЧЕНИЕ PASS_2

Проект **не предназначен для написания текстов страниц**.

PASS_2:
- генерирует **исключительно структурированные JSON-артефакты**;
- не пишет тексты страниц, блоков, абзацев, описаний или черновиков;
- не формирует контент, пригодный для прямой публикации;
- не вводит новые медицинские сущности
  (заболевания, симптомы, методы диагностики или лечения),
  отсутствующие в snapshot.

Любая попытка генерации текстового контента в PASS_2
считается **нарушением архитектурного контракта проекта**.

- заполняет каждый узел структурированными данными (deliverables),
  строго в рамках intent и границ узла, заданных в snapshot;
- генерирует вопросы, ключевые слова и анкоры (в JSON),
  не расширяя архитектуру и не добавляя новые смысловые области;
- собирает итоговые агрегаты (final_artifacts.json, execution_result.json).

При этом LLM **не может**:

- добавлять новые страницы;
- удалять существующие;
- менять структуру;
- изменять связи между страницами.

PASS_2 — это строгое исполнение зафиксированной архитектуры.
PASS_2 не принимает архитектурных решений
и не расширяет структуру snapshot ни в явной, ни в скрытой форме.

### Почему это разделено

Если не разделять эти шаги, LLM будет одновременно:
- менять структуру,
- писать контент,
- «улучшать» задним числом.

В таком режиме результат невозможно проверить или воспроизвести.

Разделение PASS_1 / PASS_2:

- лишает LLM права самовольно менять структуру;
- даёт контроль над процессом;
- делает результат проверяемым.

---

## Обязательные проверки (гейты/контракты)

### Соглашение о проверках (архитектурный контракт)

Проверки являются частью архитектуры проекта. Их состав, имена, формат вывода и семантика статусов фиксируются в README и не могут изменяться неявно.

Любое изменение соглашения о проверках считается архитектурным изменением и требует пересмотра проекта.

#### Канонические файлы проверок

Следующие проверки считаются обязательными и каноническими:

- `scripts/gate_snapshot.py` — проверка структуры и валидности snapshot.
- `scripts/check_immutability.py` — проверка immutability snapshot (hash, immutable-поля, fingerprints prompts).
- `scripts/check_approve.py` — проверка наличия approve-файла для snapshot.
- `scripts/check_deliverables.py` — post-check результатов PASS_2 (покрытие node_id, валидность anchors, aggregate-артефакты).

Переименование, удаление или подмена этих файлов без обновления соглашения считается нарушением архитектурного контракта.

#### Единый формат вывода проверок

Каждая проверка обязана возвращать результат в едином формате (независимо от реализации):

- `CHECK_NAME` — каноническое имя проверки.
- `STATUS` — `PASS` или `FAIL`.
- `BLOCKER` — `true` или `false`.
- `ERRORS` — список машинно-читаемых кодов ошибок.
- `EVIDENCE` — факты, на основе которых вынесен результат (пути, поля, значения).

Формат может быть текстовым или JSON, но семантика полей обязательна и стабильна.

#### Правила FAIL / BLOCKER

- Любой `FAIL` в обязательных проверках считается `BLOCKER=true`.
- BLOCKER немедленно останавливает pipeline.
- Статусы `WARNING`, `PARTIAL`, `SKIPPED`, `SOFT_FAIL` запрещены.
- Pipeline считается валидным **только если все проверки завершились со статусом `PASS`**.

Проект не допускает частично корректных результатов.

---

## Lifecycle состояния и snapshot (канонический)

Проект работает как конечный автомат: состояния фиксированы, переходы однозначны.

### Lifecycle snapshot (каноническая цепочка)

Диаграмма состояний (каноническая):
```
[DECIDE / PASS_1]
|
| emits
v
[snapshot.json] -----> [sha256]
| |
| | identifies immutable_architecture
v v
[approve] (POINT OF NO RETURN)
|
| unlocks
v
[execute / PASS_2]
|
| produces
v
[outputs] -> (post-check deliverables required)

```

DECIDE  
→ snapshot.json  
→ sha256  
→ approve  
→ execute  
→ outputs  

Где:

- **DECIDE** — PASS_1 принимает архитектурные решения и формирует snapshot-кандидат.
- **snapshot.json** — файл архитектурного решения (вместе с fingerprint prompts и ссылкой на входные данные).
- **sha256** — детерминированный hash immutable-части snapshot (архитектура + fingerprints prompts).
- **approve** — человеческая точка ответственности: создаётся approval-файл для hash.
- **execute** — PASS_2 исполняет snapshot, строго без архитектурных изменений.
- **outputs** — deliverables PASS_2 + служебные артефакты выполнения, далее обязательный post-check.

### Точка невозврата

**Точка невозврата — это `approve`.**  
После появления approval-файла snapshot считается **immutable** и становится архитектурным контрактом.

### Что запрещено делать после approve

После `approve` запрещено:

- менять `node_registry`, типы узлов, `hub_chain`, `linking_matrix_skeleton`, ownership;
- менять любые поля, входящие в immutable-часть snapshot;
- менять `input/task.json`, если он считается источником для данного snapshot;
- изменять `prompts/pass_1_decide.md` или `prompts/pass_2_execute.md` **без выпуска нового snapshot и нового approve**;
- исполнять PASS_2, если hash / fingerprints не совпадают с зафиксированными в snapshot;
- вручную редактировать файлы в `outputs/` (такие результаты считаются архитектурно недействительными).

Единственный допустимый способ “что-то поправить” после approve:
**выпустить новый snapshot (DECIDE заново) и получить новый approve.**

## Инварианты проекта

Следующие правила являются **архитектурным контрактом** проекта и не подлежат «аккуратным улучшениям» или смягчению формулировок:

- PASS_1 и PASS_2 никогда не объединяются.
- PASS_2 не может менять архитектуру snapshot.
- Snapshot после approve считается immutable.
- Snapshot валиден только вместе с исходным `input/task.json`  и зафиксированными версиями системных prompt-файлов.
- Любой результат без post-check считается недействительным.
- LLM не является источником истины о состоянии проекта.
- LLM запрещено генерировать тексты страниц или любой публикуемый контент.
- PASS_2 допускает только структурированные JSON-артефакты.
- Ручное редактирование любых файлов в `outputs/` запрещено.

Любое изменение, нарушающее эти правила, считается архитектурной ошибкой.

## Stateless-природа LLM (жёсткий архитектурный контракт)

LLM в проекте **semantic-cocon является строго stateless-компонентом**.

Это означает:

- LLM **не хранит состояние** между шагами, вызовами или фазами workflow.
- LLM **не обладает памятью о предыдущих шагах**, если соответствующее состояние
  не передано ей явно во входных данных текущего шага.
- LLM **не может быть источником истины** о прошлом, текущем или будущем состоянии pipeline.

### Где живёт состояние проекта

Единственным источником истины о состоянии проекта являются:

- каталог `state/`, включая:
  - `state/snapshots/`
  - `state/approvals/`
- результаты проверок, выполняемых кодом (`gate`, `post-check`).

LLM **не имеет права**:

- утверждать, что предыдущий шаг был выполнен успешно;
- предполагать наличие approve без явного approval-файла;
- считать snapshot актуальным без его явной передачи;
- опираться на историю диалога как на подтверждение состояния.

### Запрещённые предположения

Считается архитектурным нарушением, если LLM:

- использует формулировки вида:
  - «как мы уже сделали ранее»,
  - «на прошлом шаге было подтверждено»,
  - «мы уже зафиксировали архитектуру» — без переданного snapshot;
- продолжает workflow без явного сигнала пользователя;
- принимает решения на основе неявных предположений о прошлом состоянии.

### Следствие

Каждый шаг workflow LLM обязана рассматривать **как изолированный и не связанный с предыдущими**, если состояние не передано явно через:
- snapshot,
- входной JSON,
- аргументы команды,
- или иные формализованные артефакты.

Любая логика, основанная на «памяти» или «контексте диалога», считается недействительной.


## Общая архитектура workflow

Workflow состоит из **двух жёстко разделённых проходов**:

- **PASS_1 — DECIDE**: принятие архитектурных решений
- **PASS_2 — EXECUTE**: исполнение строго по зафиксированной архитектуре

Между ними находятся обязательные контрольные точки:

```
DECIDE
  ↓
SNAPSHOT + HASH
  ↓
APPROVE (human)
  ↓
EXECUTE
  ↓
POST-CHECK (deliverables)
```

Каждый шаг либо проходит валидацию, либо останавливает процесс.

---

## PASS_1: DECIDE

### Назначение

PASS_1 **не генерирует контент**.
Он принимает **архитектурные решения**, которые фиксируются в snapshot и становятся контрактом (immutable) **после approve**.

---

### `prompts/pass_1_decide.md` — контракт архитектурного мышления

`pass_1_decide.md` — это **канонический системный промпт PASS_1**, отвечающий
**исключительно** за принятие архитектурных решений.

Он используется **только** на этапе `DECIDE`
и **никогда** не участвует в генерации семантики или контента.

#### Что делает этот промпт

`pass_1_decide.md` определяет:

- состав и структуру `node_registry`;
- типы узлов (`HUB / SPOKE / SUPPORT`);
- `hub_chain` — основную навигационную цепочку;
- `linking_matrix_skeleton` — допустимые внутренние связи;
- ownership узлов (`owner_status`, `canonical_home`);
- архитектурные альтернативы (forced contradiction), если они предусмотрены схемой;
- архитектурные якоря (в частности, `clinical_entity_registry`).

Если схема ARCH_DECISION_JSON предусматривает `salient_terms`
в составе клинических сущностей, они рассматриваются как
архитектурный механизм различения медицинских интентов
и предотвращения скрытой каннибализации узлов.

`salient_terms` в PASS_1:
- не являются семантикой;
- не используются для генерации ключевых слов или контента;
- служат исключительно для архитектурного разведения сущностей и узлов.

Если `clinical_entity_registry` присутствует в схеме ARCH_DECISION_JSON,
он является обязательным архитектурным якорем:
архитектура формируется ИСКЛЮЧИТЕЛЬНО на основе сущностей,
описанных в этом реестре.

Важно:
PASS_1 не просто "описывает структуру",
а жёстко ограничивает допустимую архитектуру правилами проектирования
(медицинская валидность, запрет ассоциативного расширения,
анти-каннибализация на уровне сущностей).

Результатом работы промпта является **только** `ARCH_DECISION_JSON`, который далее:
- канонизируется;
- хешируется;
- сохраняется как snapshot-кандидат;
- становится immutable **только после approve**.

#### Чего **никогда** не должно быть в `pass_1_decide.md`

Следующие вещи являются **архитектурно запрещёнными** для PASS_1
и считаются нарушением контракта проекта:

- генерация любого контента:
  - текстов страниц,
  - абзацев,
  - описаний,
  - черновиков;
- генерация семантики:
  - ключевых слов,
  - анкоров,
  - вопросов пациента,
  - semantic enrichment;
- self-audit и внутренняя валидация:
  - «проверь, что…»,
  - «если нарушено…»,
  - «убедись, что…»,
  - «остановись, если…»;
- контроль состояния или жизненного цикла:
  - проверка approve,
  - проверка immutability,
  - решение о возможности перехода к PASS_2;
- любые попытки:
  - хранить состояние,
  - ссылаться на предыдущие шаги,
  - использовать историю диалога как источник истины.

PASS_1 **не проверяет себя**
и **не решает, можно ли продолжать workflow**.

Его задача — выдать архитектурное решение
строго в рамках заданных ограничений,
а не оценивать корректность или исполнимость результата.

Все проверки и контроль выполняются **вне LLM**, в коде.

#### Что считается допустимым внутри PASS_1

В рамках `pass_1_decide.md` **допустимы**:

- декларативные правила генерации архитектуры
  (жёсткие ограничения пространства решений, но не их проверка),
  включая:
  - использование клинического реестра сущностей как источника истины;
  - запрет расширения архитектуры "по ассоциации" без клинического обоснования;
  - запрет латентной каннибализации одной и той же сущности
    через несколько доминирующих узлов.
- требование обоснования архитектурных решений
  (например, ownership rationale или why-variant-is-worse);
- жёсткие доменные и медицинские приоритеты;
- формирование альтернатив архитектуры
  без оценки «качества результата».

Это **не self-audit**, а часть процесса принятия решений.

#### Статус промпта как артефакта

`prompts/pass_1_decide.md` является **частью immutable-контракта snapshot**:

- его fingerprint включается в `*.sha256`;
- любое изменение файла:
  - считается изменением архитектурной логики;
  - требует выпуска нового snapshot;
  - требует нового approve;
- изменение промпта **после approve** запрещено
  для текущего snapshot.

Если `pass_1_decide.md` был изменён —
**старые snapshot’ы считаются несовместимыми
с новой версией архитектуры системы**.

### Что именно определяется

- `node_registry` — список узлов
- типы узлов: `HUB / SPOKE / SUPPORT`
- `hub_chain` — цепочка главного хаба
- `linking_matrix_skeleton` — скелет внутренней линковки
- ownership узлов (owner records)

### Источники данных

- `input/task.json` — входная постановка задачи
- `prompts/pass_1_decide.md` — системный промпт PASS_1
- LLM вызывается через `scripts/llm_cli_bridge.py`

### Результат PASS_1

PASS_1 формирует snapshot архитектуры и фиксирует fingerprint всех системных prompt-файлов, используемых для данного workflow.

Fingerprint prompt-файла — это детерминированный hash его канонического содержимого.

Fingerprint используется:
- при формировании `*.sha256`;
- при проверке неизменяемости snapshot перед EXECUTE;
- для доказательства воспроизводимости результата.

PASS_1 формирует snapshot архитектуры:

- `*.snapshot.json` — зафиксированное решение архитектуры  вместе с версиями используемых системных prompts
- `*.canonical.json` — каноническое представление
- `*.sha256` — hash immutable-части snapshot, включая архитектуру и fingerprint используемых prompt-файлов

Файлы сохраняются в:

```
state/snapshots/
```

После этого архитектура считается **кандидатом на approve**: её нельзя “подкручивать” в рамках PASS_2, а любые изменения оформляются только через новый snapshot и повторный approve.

---

## Snapshot и принцип immutability

Snapshot — это фиксация архитектурного решения в JSON вместе с входными данными, на основе которых оно было принято.

Snapshot после approve считается immutable.
Контракт вступает в силу (становится immutable) **только после шага APPROVE**.

Snapshot считается валидным **только в связке с тем `input/task.json`**, на основе которого он был сформирован.
Любая подмена или изменение `task.json` после PASS_1 аннулирует валидность snapshot.

В блоке `immutable_architecture` находятся поля, которые считаются immutable **после approve**:

- `node_registry`
- `hub_chain`
- `linking_matrix_skeleton`
- `owner_map` (фактически список owner-records)
- fingerprints системных prompt-файлов:
  - `prompts/pass_1_decide.md`
  - `prompts/pass_2_execute_core.md`
  - `prompts/pass_2_execute_anchors.md`

Любая попытка:
- изменить количество узлов,
- поменять тип узла,
- изменить линковку

после approve должна приводить к отказу исполнения PASS_2.
До approve такие изменения допускаются **только через выпуск нового snapshot**, а не правку существующего.

---

## APPROVE (человеческий шаг)

Snapshot **запрещено исполнять без APPROVE**.
Отсутствие approval-файла является безусловным основанием для отказа запуска PASS_2.

Для разрешения EXECUTE требуется файл подтверждения.
Автоматическое или программное создание approval-файла запрещено.

```
state/approvals/<hash>.approved
```

Где `<hash>` — значение из `*.sha256` snapshot-файла.
Любое изменение snapshot (даже минимальное) требует **нового approve** и нового approval-файла.

Это:
- явная точка ответственности человека,
- момент, после которого snapshot считается immutable,
- защита от самовольного исполнения,
- жёсткое отделение «решения» от «исполнения».

---

## PASS_2: EXECUTE

### Назначение

PASS_2 **не принимает архитектурных решений**.
Он строго исполняет то, что зафиксировано в snapshot.

### Проверки перед запуском

Перед началом EXECUTE:

- проверяется hash snapshot
- проверяется наличие approval-файла
- проверяется неизменяемость immutable-части snapshot
- проверяется совпадение fingerprint системных prompt-файлов с зафиксированными в snapshot

При несовпадении fingerprint EXECUTE запрещён.

Без этих условий PASS_2 не запускается.

### Источники данных

- `state/snapshots/*.snapshot.json` — архитектура
- `prompts/pass_2_execute_core.md` — системный промпт PASS_2A (CORE)
- `prompts/pass_2_execute_anchors.md` — системный промпт PASS_2B (ANCHORS)
- LLM через `scripts/llm_cli_bridge.py`

### Результат PASS_2

PASS_2 создаёт deliverables **поэтапно**:

outputs/pass_2/<snapshot_id>/
├── core/
│ ├── semantic_enrichment.json
│ ├── keywords.json
│ ├── patient_questions.json
│ ├── execution_result_core.json
│ └── execution_result_core.raw.txt
│
├── anchors/
│ ├── anchors.json
│ ├── execution_result_anchors.json
│ └── execution_result_anchors.raw.txt
│
└── (merge step produces final execution_result.json)

Post-check выполняется **только после merge core + anchors**.

Merge:
- выполняется **внешним кодом (Python)**,
- не является задачей LLM,
- не допускает интерпретации или пересборки данных,
- представляет собой детерминированное объединение
  `core/*` и `anchors/*` в единый `execution_result.json`.

---

## Типы изменений и где они допустимы

Каждый тип изменения в проекте имеет **строго определённое место** в workflow.
Если изменение внесено не на своём этапе — это считается архитектурной ошибкой,
даже если результат выглядит логически корректным.

| Тип изменения | Где допустимо |
|---------------|---------------|
| Изменение структуры узлов (node_registry) | PASS_1 |
| Изменение типов узлов (HUB / SPOKE / SUPPORT) | PASS_1 |
| Изменение hub_chain | PASS_1 |
| Изменение линковки (linking_matrix_skeleton) | PASS_1 |
| Изменение ownership (canonical_home, owner_status) | PASS_1 |
| Изменение семантических артефактов (keywords, questions, enrichment, anchors) | PASS_2 |
| Изменение формата или состава deliverables | PASS_2 |
| Изменение проверок snapshot или deliverables | scripts / orchestrator |
| Изменение логики approve или enforcement immutability | orchestrator |

Если изменение не попадает ни в одну из указанных категорий, оно считается некорректно сформулированным и подлежит пересмотру постановки задачи.

## Типы deliverables

### Per-node артефакты

Должны покрывать **все `node_id` из snapshot**, включая `SUPPORT`-узлы.

Тип узла (`HUB / SPOKE / SUPPORT`) **не влияет на обязанность**
иметь per-node deliverables.

При этом:
- `SUPPORT`-узлы **могут не участвовать в anchors**,
  если это не предусмотрено `linking_matrix_skeleton`.

- `keywords.json`
- `patient_questions.json`
  (вопросы формулируются строго в рамках узла
  и не используются для расширения или коррекции архитектуры)
- `semantic_enrichment.json`

### Link‑level артефакты

- `anchors.json`
- используют `from_node_id / to_node_id`
- проверяются на соответствие `linking_matrix_skeleton`

### Aggregate‑артефакты

- `final_artifacts.json`
- агрегированный итог
- не обязаны иметь `node_id`

---

## Post‑check deliverables (обязательный гейт)

После успешного EXECUTE автоматически запускается:

```
scripts/check_deliverables.py <snapshot_id>
```

Проверяется:

- покрытие всех `node_id` в per‑node артефактах
- валидность anchors
- наличие и непустота aggregate‑результатов

Если проверка не проходит:

- EXECUTE считается **проваленным**
- пайплайн останавливается

LLM не может «протащить» некорректный результат.

---

## Структура репозитория

Ключевые директории проекта:

```
input/        — входные данные задачи
prompts/      — системные промпты PASS_1 и PASS_2
scripts/      — оркестратор и проверки
state/        — snapshots, approvals, runtime-состояние
outputs/      — результаты PASS_2 (deliverables)
```

---

## Оркестратор

### Файл

```
scripts/orchestrator.py
```

### Режимы работы

- `decide`
- `execute`

`approve` является режимом orchestrator, механизирующим человеческое решение.

Команда:
```bash
python -m scripts.orchestrator approve --snapshot <snapshot_id>
```
- НЕ принимает решение за человека
- НЕ проверяет корректность snapshot только создаёт state/approvals/<hash>.approved

---

## Итог (без похвалы)
После этих diff-правок README **перестаёт врать** и начинает:
- отражать stage-архитектуру,
- фиксировать реальные failure-классы,
- документировать approve как часть workflow,
- соответствовать текущему коду.

Если хочешь, следующим шагом можем:
- добавить раздел **MERGE (CORE + ANCHORS)**,
- или зафиксировать **инварианты stage-split как STOP-conditions**.

Но сначала — **примени эти правки**.

Запуск **только как модуль**:

```bash
python -m scripts.orchestrator <command>
```

Оркестратор:

- не хранит состояние
- не доверяет LLM
- управляет порядком шагов и проверками

---

## Канонический ручной workflow

Этот раздел описывает тот же процесс, что и Quick Start, но в более формальном и проверяемом виде.

Для одного snapshot:

```bash
python scripts/gate_snapshot.py <snapshot_id>
# создать approvals/<hash>.approved
python -m scripts.orchestrator execute --snapshot state/snapshots/<snapshot_id>.snapshot.json
python scripts/check_deliverables.py <snapshot_id>
```

Если любой шаг падает — процесс считается неуспешным.

---

## Ответственности компонентов

| Компонент | Ответственность |
|---------|----------------|
| PASS_1 | Архитектура |
| Snapshot | Контракт (immutable после approve) |
| Approve | Человеческое решение |
| PASS_2 | Исполнение |
| Post-check | Контроль качества |
| Orchestrator | Порядок и запреты |

---

## Ответственность за артефакты и правила изменений

Каждый артефакт в проекте имеет владельца, допустимые моменты изменения
и жёсткое правило, требует ли его изменение нового approve.

Если артефакт изменён вне разрешённого окна —
результат считается **архитектурно недействительным**,
даже если pipeline технически отработал.

| Артефакт | Владелец | Когда можно менять | Требует approve |
|--------|----------|-------------------|-----------------|
| `input/task.json` | Человек | **Только до PASS_1** | Да (через новый snapshot) |
| `prompts/pass_1_decide.md` | Человек / Архитектор | До запуска PASS_1 | Да (через новый snapshot) |
| `prompts/pass_2_execute_core.md` | Человек / Архитектор | Только до формирования snapshot | Да (через новый snapshot) |
| `prompts/pass_2_execute_anchors.md` | Человек / Архитектор | Только до формирования snapshot | Да (через новый snapshot) |
| `*.snapshot.json` | PASS_1 | До approve | Нет |
| `*.canonical.json` | Python (system) | Никогда вручную | Нет |
| `*.sha256` | Python (system) | Никогда | Нет |
| `state/approvals/*.approved` | Человек | Один раз на snapshot | — |
| `outputs/pass_2/**.json` | PASS_2 | Только в рамках EXECUTE | Нет |
| `execution_result.json` | PASS_2 | Только в рамках EXECUTE | Нет |
| `execution_result.raw.txt` | System log | Никогда вручную | Нет |
| `scripts/*.py` | Человек / Архитектор | В любое время | Нет (но влияет на все future runs) |

Дополнительно:

- `input/task.json` считается частью архитектурного контекста snapshot.  Любое его изменение после PASS_1 автоматически требует  выпуска нового snapshot и нового approve.
- Любое изменение файлов `prompts/pass_1_decide.md`   или `prompts/pass_2_execute.md`   считается **изменением архитектурной логики системы**  и допускается только через выпуск нового snapshot и новый approve.
- Ручное редактирование любых файлов в `outputs/`   запрещено. Такие результаты считаются архитектурно недействительными   и не подлежат post-check.

---

## Что проект **не** делает

Важно понимать ограничения проекта:

- проект **не** предназначен для «просто генерации текста»
- LLM **не** принимает финальные решения
- результат **не** считается корректным без проверок
- пайплайн **не** продолжает работу при нарушении архитектуры

Если нужен быстрый, неконтролируемый вывод — этот проект избыточен.

---

## Итог

`semantic-cocon` превращает работу с LLM из генерации «на доверии» в **проверяемый инженерный процесс**:

- архитектура отделена от исполнения
- решения фиксируются
- каждое действие верифицируется
- результат либо доказуемо корректен, либо отвергнут

Это основа для масштабируемых и воспроизводимых LLM‑систем.

## Observed & Fixed Failure Classes

### LLM_OUTPUT_TRUNCATED (PASS_2 / ANCHORS)

**Где выявлено:**  
Smoke-test PASS_2B (ANCHORS)

**Суть проблемы:**  
Даже при корректной архитектуре и валидных связях LLM не укладывалась в лимит output при генерации anchors (много вариантов анкоров, пояснений, narrative).

**Причина:**  
Монолитный PASS_2 с генерацией per-node и per-link артефактов
в одном вызове LLM.

**Исправление:**  
- PASS_2 разделён на два stage:
  - PASS_2A (CORE) — per-node артефакты
  - PASS_2B (ANCHORS) — link-level артефакты
- В PASS_2B зафиксирован жёсткий контракт:
  - EXACTLY 1 anchor per (from_node_id, to_node_id)
  - max 60 символов
  - без вариантов и пояснений
- Post-check вынесен за пределы отдельных stage.

**Статус:** FIXED

Этот раздел фиксирует классы отказов, выявленные при реальных smoke-test прогонах, и способы их устранения.  
Цель — предотвратить повторное появление архитектурных нарушений и зафиксировать эволюцию контрактов системы.

### INVALID_NODE_ID_IN_ANCHORS

**Где выявлено:**  
Smoke-test PASS_2 / EXECUTE

**Суть проблемы:**  
LLM сгенерировала `from_node_id / to_node_id`, отсутствующие в `node_registry`
(snapshot), несмотря на корректную архитектуру PASS_1.

**Причина:**  
Недостаточно жёсткий контракт генерации `anchors` в PASS_2
(отсутствие явного allowlist и запрета модификации `node_id`).

**Исправление:**  
- Усилен контракт PASS_2:
  - `anchors` могут использовать **только** `node_id` из snapshot
  - разрешены **только** пары из `linking_matrix_skeleton`
- Post-check (`check_deliverables.py`) усилен:
  - `bad_rows > 0` → BLOCKER

**Статус:** FIXED

### FINAL_ARTIFACTS_WRONG_TYPE

**Где выявлено:**  
Smoke-test PASS_2 / EXECUTE

**Суть проблемы:**  
`final_artifacts.json` был сгенерирован как list,
в то время как post-check и downstream-логика ожидают агрегированный object (dict).

**Причина:**  
Неявный контракт формата `final_artifacts` в PASS_2 prompt.

**Исправление:**  
- В PASS_2 зафиксирован жёсткий контракт:
  - `final_artifacts` — **JSON-object (dict)**
  - обязательный ключ: `main_summary_table` (string)
  - `artifacts` (если присутствует) — **dict**, не list
- Post-check усилен:
  - неверный тип `final_artifacts` → BLOCKER

**Статус:** FIXED

## PRE-FLIGHT STOP CONDITIONS

STOP-1: Правка размывает границу DECIDE / EXECUTE
(PASS_2 начинает принимать решения или PASS_1 начинает проверять себя )

STOP-2: Правка переносит контроль внутрь LLM
(verify / approve / “проверь” / “если не получилось” )

STOP-3: Правка расширяет смысл PASS_2
(новые сущности, новые темы через enrichment / questions / keywords )

## MERGE (CORE + ANCHORS)

MERGE — отдельный обязательный шаг между PASS_2 и post-check.

Вход:
- core_snapshot_id — snapshot PASS_2A / CORE
- anchors_snapshot_id — snapshot PASS_2B / ANCHORS

Выход:
- новый merge_id в outputs/pass_2/<merge_id>/
- execution_result.json
- материализованные артефакты:
  semantic_enrichment.json
  keywords.json
  patient_questions.json
  anchors.json

MERGE выполняется:
- только внешним Python-кодом
- без участия LLM
- без изменения содержимого артефактов

Post-check:
- ЗАПРЕЩЕНО выполнять post-check для CORE или ANCHORS snapshot
- РАЗРЕШЕНО выполнять post-check ТОЛЬКО для merge_id