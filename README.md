Зачем каждый каталог

**prompts/**
- pass_1_decide.md — промпт, который ТОЛЬКО принимает архитектурные решения.
- pass_2_execute.md — промпт, который ТОЛЬКО исполняет зафиксированную архитектуру.

**input/**
- task.json — вход задачи: domain, goal, region, seed-данные.
Этот файл один и тот же для PASS_1 и PASS_2.

**state/**
- snapshots/ — сохранённые ARCH_DECISION_JSON + hash.
- approvals/ — файлы человеческого подтверждения (флаг, подпись, whatever).
LLM сюда не пишет. Только Python.

**outputs**
- pass_2/ — финальные артефакты PASS_2: структурированные JSON-deliverables и сводные результаты (при необходимости — вспомогательные MD-отчёты, но не тексты страниц).
Всё, что можно отдать дальше в работу.

**scripts/**
- state_utils.py — canonicalize, hash, save, load, verify.
- orchestrator.py — decide / approve / execute.
Без классов ради классов. Это не фреймворк, это инструмент.


Вот README проекта. Используй его как описание архитектуры и принципов работы.

# semantic-cocon

## Назначение проекта

> Workflow для работы с LLM, где сначала принимаются решения, затем выполняется генерация, а результат можно проверить и воспроизвести.
> Детерминированный двухпроходный workflow работы с LLM: архитектура отдельно, исполнение отдельно, результат — проверяемый.

Ключевая идея проекта:
> LLM не управляет состоянием, не проверяет саму себя и не принимает финальные решения.
> Она используется только как исполнитель строго заданных шагов.

Проект решает типичную проблему LLM‑подходов:
- архитектура «плывёт» от запуска к запуску,
- результат невозможно воспроизвести,
- нельзя доказать, что выход соответствует принятой структуре.

В `semantic-cocon` это запрещено на уровне пайплайна.

---

## Быстрый старт (Quick Start)

Ниже — минимальный сценарий, который позволяет запустить проект и пройти весь цикл от архитектуры до проверенного результата.

```bash
# PASS_1 — принять архитектурные решения
python -m scripts.orchestrator decide

# проверить корректность snapshot
python scripts/gate_snapshot.py <snapshot_id>

# подтвердить snapshot (human step)
# создать файл state/approvals/<hash>.approved
# gate_snapshot — техническая проверка, не заменяет approve

# PASS_2 — выполнить генерацию по зафиксированной архитектуре
python -m scripts.orchestrator execute --snapshot state/snapshots/<snapshot_id>.snapshot.json

# POST-CHECK — без него результат считается недействительным
python scripts/check_deliverables.py <snapshot_id>
```

Если любой шаг завершается с ошибкой — процесс считается неуспешным.

---

## Как понимать PASS_1 и PASS_2 (если коротко)

Проект намеренно разделяет работу с LLM на два разных шага, потому что это **разные по смыслу действия**.

### PASS_1 — DECIDE (принять решения)

На этом шаге мы решаем **ЧТО именно будем делать**, но ничего ещё не генерируем.

Проще всего думать о PASS_1 как о **плане или чертеже**:

- какие страницы (узлы) будут существовать;
- какая страница главная;
- какие страницы второстепенные;
- какие страницы вспомогательные;
- какие страницы должны ссылаться друг на друга.

На PASS_1 LLM **запрещено писать контент**. Она не генерирует тексты, вопросы или ключевые слова. Она только описывает структуру будущего результата.

Результат PASS_1 — это зафиксированная архитектура (snapshot). Контрактом (immutable) она становится после approve; до approve допускается только выпуск нового snapshot, а не правки старого.

### PASS_2 — EXECUTE (сгенерировать deliverables по зафиксированной архитектуре)

⚠️ Это **единственный шаг всего workflow, на котором LLM генерирует выходные артефакты** (структурированные данные), а не принимает решения.

На этом шаге мы делаем ровно то, что уже решили на PASS_1.

LLM получает готовый "чертёж" и:

Важно: проект **не предназначен для написания текстов страниц**. PASS_2 генерирует только структурированные deliverables (например, ключевые слова, вопросы, анкоры, сводные таблицы) в формате JSON.

- заполняет каждый узел структурированными данными (deliverables);
- генерирует вопросы, ключевые слова, анкоры (в JSON);
- собирает итоговые агрегаты (final_artifacts.json, execution_result.json).

При этом LLM **не может**:

- добавлять новые страницы;
- удалять существующие;
- менять структуру;
- изменять связи между страницами.

PASS_2 — это строгое исполнение зафиксированной архитектуры без права передумывать.

### Почему это разделено

Если не разделять эти шаги, LLM будет одновременно:
- менять структуру,
- писать контент,
- «улучшать» задним числом.

В таком режиме результат невозможно проверить или воспроизвести.

Разделение PASS_1 / PASS_2:

- лишает LLM права самовольно менять структуру;
- даёт контроль над процессом;
- делает результат проверяемым.

---

## Инварианты проекта

Следующие правила являются **архитектурным контрактом** проекта и не подлежат «аккуратным улучшениям» или смягчению формулировок:

- PASS_1 и PASS_2 никогда не объединяются.
- PASS_2 не может менять архитектуру snapshot.
- Snapshot после approve считается immutable.
- Любой результат без post-check считается недействительным.
- LLM не является источником истины о состоянии проекта.


Любое изменение, нарушающее эти правила, считается архитектурной ошибкой.

---

## Общая архитектура workflow

Workflow состоит из **двух жёстко разделённых проходов**:

- **PASS_1 — DECIDE**: принятие архитектурных решений
- **PASS_2 — EXECUTE**: исполнение строго по зафиксированной архитектуре

Между ними находятся обязательные контрольные точки:

```
DECIDE
  ↓
SNAPSHOT + HASH
  ↓
APPROVE (human)
  ↓
EXECUTE
  ↓
POST-CHECK (deliverables)
```

Каждый шаг либо проходит валидацию, либо останавливает процесс.

---

## PASS_1: DECIDE

### Назначение

PASS_1 **не генерирует контент**.
Он принимает **архитектурные решения**, которые фиксируются в snapshot и становятся контрактом (immutable) **после approve**.

### Что именно определяется

- `node_registry` — список узлов
- типы узлов: `HUB / SPOKE / SUPPORT`
- `hub_chain` — цепочка главного хаба
- `linking_matrix_skeleton` — скелет внутренней линковки
- ownership узлов (owner records)

### Источники данных

- `input/task.json` — входная постановка задачи
- `prompts/pass_1_decide.md` — системный промпт PASS_1
- LLM вызывается через `scripts/llm_cli_bridge.py`

### Результат PASS_1

PASS_1 формирует snapshot архитектуры:

- `*.snapshot.json` — зафиксированное решение
- `*.canonical.json` — каноническое представление
- `*.sha256` — hash части snapshot, которая считается immutable после approve

Файлы сохраняются в:

```
state/snapshots/
```

После этого архитектура считается **кандидатом на approve**: её нельзя “подкручивать” в рамках PASS_2, а любые изменения оформляются только через новый snapshot и повторный approve.

---

## Snapshot и принцип immutability

Snapshot — это фиксация архитектурного решения в JSON (проект контракта).
Snapshot после approve считается immutable.
Контракт вступает в силу (становится immutable) **только после шага APPROVE**.

В блоке `immutable_architecture` находятся поля, которые считаются immutable **после approve**:

- `node_registry`
- `hub_chain`
- `linking_matrix_skeleton`
- `owner_map` (фактически список owner‑records)

Любая попытка:
- изменить количество узлов,
- поменять тип узла,
- изменить линковку

после approve должна приводить к отказу исполнения PASS_2.
До approve такие изменения допускаются **только через выпуск нового snapshot**, а не правку существующего.

---

## APPROVE (человеческий шаг)

Snapshot **запрещено исполнять без APPROVE**.
Отсутствие approval-файла является безусловным основанием для отказа запуска PASS_2.

Для разрешения EXECUTE требуется файл подтверждения.
Автоматическое или программное создание approval-файла запрещено.

```
state/approvals/<hash>.approved
```

Где `<hash>` — значение из `*.sha256` snapshot-файла.
Любое изменение snapshot (даже минимальное) требует **нового approve** и нового approval-файла.

Это:
- явная точка ответственности человека,
- момент, после которого snapshot считается immutable,
- защита от самовольного исполнения,
- жёсткое отделение «решения» от «исполнения».

---

## PASS_2: EXECUTE

### Назначение

PASS_2 **не принимает архитектурных решений**.
Он строго исполняет то, что зафиксировано в snapshot.

### Проверки перед запуском

Перед началом EXECUTE:

- проверяется hash snapshot
- проверяется наличие approval‑файла
- проверяется неизменяемость immutable‑части

Без этих условий PASS_2 не запускается.

### Источники данных

- `state/snapshots/*.snapshot.json` — архитектура
- `prompts/pass_2_execute.md` — системный промпт PASS_2
- LLM через `scripts/llm_cli_bridge.py`

### Результат PASS_2

PASS_2 создаёт набор deliverables:

```
outputs/pass_2/<snapshot_id>/
├── keywords.json
├── patient_questions.json
├── semantic_enrichment.json
├── anchors.json
├── final_artifacts.json
├── execution_result.json
└── execution_result.raw.txt
```

---

## Где допустимы изменения

Тип изменения напрямую определяет, **на каком шаге оно может быть внесено**:

| Тип изменения | Где допустимо |
|--------------|---------------|
| Изменение структуры узлов | PASS_1 |
| Изменение типов узлов (HUB / SPOKE / SUPPORT) | PASS_1 |
| Изменение линковки | PASS_1 |
| Изменение контента узлов | PASS_2 |
| Изменение анкоров | PASS_2 |
| Изменение проверок | scripts / orchestrator |
| Изменение логики approve | orchestrator |

Если изменение не попадает ни в одну категорию — оно считается некорректно сформулированным.

---

## Типы deliverables

### Per‑node артефакты

Должны покрывать **все `node_id` из snapshot**:

- `keywords.json`
- `patient_questions.json`
- `semantic_enrichment.json`

### Link‑level артефакты

- `anchors.json`
- используют `from_node_id / to_node_id`
- проверяются на соответствие `linking_matrix_skeleton`

### Aggregate‑артефакты

- `final_artifacts.json`
- агрегированный итог
- не обязаны иметь `node_id`

---

## Post‑check deliverables (обязательный гейт)

После успешного EXECUTE автоматически запускается:

```
scripts/check_deliverables.py <snapshot_id>
```

Проверяется:

- покрытие всех `node_id` в per‑node артефактах
- валидность anchors
- наличие и непустота aggregate‑результатов

Если проверка не проходит:

- EXECUTE считается **проваленным**
- пайплайн останавливается

LLM не может «протащить» некорректный результат.

---

## Структура репозитория

Ключевые директории проекта:

```
input/        — входные данные задачи
prompts/      — системные промпты PASS_1 и PASS_2
scripts/      — оркестратор и проверки
state/        — snapshots, approvals, runtime-состояние
outputs/      — результаты PASS_2 (deliverables)
```

---

## Оркестратор

### Файл

```
scripts/orchestrator.py
```

### Режимы работы

- `decide`
- `execute`

`approve` не является режимом orchestrator и выполняется **исключительно человеком** путём создания approval-файла.

Запуск **только как модуль**:

```bash
python -m scripts.orchestrator <command>
```

Оркестратор:

- не хранит состояние
- не доверяет LLM
- управляет порядком шагов и проверками

---

## Канонический ручной workflow

Для одного snapshot:

```bash
python scripts/gate_snapshot.py <snapshot_id>
# создать approvals/<hash>.approved
python -m scripts.orchestrator execute --snapshot state/snapshots/<snapshot_id>.snapshot.json
python scripts/check_deliverables.py <snapshot_id>
```

Если любой шаг падает — процесс считается неуспешным.

---

## Ответственности компонентов

| Компонент | Ответственность |
|---------|----------------|
| PASS_1 | Архитектура |
| Snapshot | Контракт (immutable после approve) |
| Approve | Человеческое решение |
| PASS_2 | Исполнение |
| Post‑check | Контроль качества |
| Orchestrator | Порядок и запреты |

---

## Что проект **не** делает

Важно понимать ограничения проекта:

- проект **не** предназначен для «просто генерации текста»
- LLM **не** принимает финальные решения
- результат **не** считается корректным без проверок
- пайплайн **не** продолжает работу при нарушении архитектуры

Если нужен быстрый, неконтролируемый вывод — этот проект избыточен.

---

## Итог

`semantic-cocon` превращает работу с LLM из генерации «на доверии» в **проверяемый инженерный процесс**:

- архитектура отделена от исполнения
- решения фиксируются
- каждое действие верифицируется
- результат либо доказуемо корректен, либо отвергнут

Это основа для масштабируемых и воспроизводимых LLM‑систем.



